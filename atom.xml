<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vincent Guc]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-12-18T02:06:54.443Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Vincent Guc]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Implement strStr]]></title>
    <link href="http://yoursite.com/2015/12/18/Implement-strStr/"/>
    <id>http://yoursite.com/2015/12/18/Implement-strStr/</id>
    <published>2015-12-18T01:58:59.000Z</published>
    <updated>2015-12-18T02:06:54.443Z</updated>
    <content type="html"><![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<a id="more"></a>
<p>题目大意是判断字符串是否是另一个字符串的子串，并返回第一次出现的索引。</p>
<h1 id="解题思路">解题思路</h1><p>一边遍历两个字符串边比较，如果两个对应位置上的字符相等，继续遍历，否则退回到刚开始匹配的下一个位置(避免错过可能的解)，再遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = j = <span class="number">0</span>; i &lt; haystack.length() &amp;&amp; j &lt; needle.length();) &#123;</span><br><span class="line">	<span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">		++i;</span><br><span class="line">		++j;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i -= j - <span class="number">1</span>;</span><br><span class="line">		j = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j != needle.length() ? -<span class="number">1</span> : i - j;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Element]]></title>
    <link href="http://yoursite.com/2015/12/18/Remove-Element/"/>
    <id>http://yoursite.com/2015/12/18/Remove-Element/</id>
    <published>2015-12-18T01:50:34.000Z</published>
    <updated>2015-12-18T01:58:07.621Z</updated>
    <content type="html"><![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<a id="more"></a>
<p>题目大意就是给定一个数组和一个值，删除数组中所有与此值相等的元素。</p>
<h1 id="解题思路">解题思路</h1><p>一种做法是用两个“指针”分别指向数组的第一个和最后一个元素，然后移动第一个指针遍历数组，如果遇到与给定值相等，用最后一个元素将当前元素覆盖来达到删除目的(如果最后一个元素也和给定值相等，则将“指针“前移知道元素不等于给定值，然后覆盖。)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>,i = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= last)&#123;</span><br><span class="line"> <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">	 <span class="keyword">if</span>(nums[last] != val)&#123;</span><br><span class="line">		 </span><br><span class="line">	     tmp = nums[i];</span><br><span class="line">	     nums[i] = nums[last];</span><br><span class="line">	     nums[last] = tmp;</span><br><span class="line">	     i++;</span><br><span class="line">	 &#125;</span><br><span class="line">	 last--;</span><br><span class="line">	 count++;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	 i++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums.length - count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted Array]]></title>
    <link href="http://yoursite.com/2015/12/18/Remove-Duplicates-from-Sorted-Array/"/>
    <id>http://yoursite.com/2015/12/18/Remove-Duplicates-from-Sorted-Array/</id>
    <published>2015-12-18T01:41:56.000Z</published>
    <updated>2015-12-18T01:50:03.842Z</updated>
    <content type="html"><![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<a id="more"></a>
<p>题目大意就是在原数组上删除那些重复的元素，然后返回数组的长度</p>
<h1 id="解题思路">解题思路</h1><p>记录数组的起始元素，然后遍历之后的数组元素，如果相等，继续遍历，如果遇到不相等的(由于起始元素到当前元素之间的元素都是重复的，所以将当前元素覆盖掉起始元素之后一位的元素，然后将起始元素往后移一位)。然后返回“新”数组的长度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> startPosition = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[startPosition]) &#123;    </span><br><span class="line">            nums[startPosition + <span class="number">1</span>] = nums[i];    </span><br><span class="line">            startPosition++;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> startPosition + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Merge Two Sorted Lists]]></title>
    <link href="http://yoursite.com/2015/12/18/Merge-Two-Sorted-Lists/"/>
    <id>http://yoursite.com/2015/12/18/Merge-Two-Sorted-Lists/</id>
    <published>2015-12-18T01:36:10.000Z</published>
    <updated>2015-12-18T01:41:16.859Z</updated>
    <content type="html"><![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<a id="more"></a>
<p>题目大意就是将两个已排序的链表合并成一个链表。</p>
<h1 id="解题思路">解题思路</h1><p>一种做法是依次比较两个链表的元素，将较小的元素拿出来放到建立的另一条链表上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		ListNode p = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">		ListNode curr = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">				curr = <span class="keyword">new</span> ListNode(l1.val);</span><br><span class="line">				<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">					head = curr;</span><br><span class="line">					p = head;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					p.next = curr;</span><br><span class="line">					p = p.next;</span><br><span class="line">				&#125;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				curr = <span class="keyword">new</span> ListNode(l2.val);</span><br><span class="line">				<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">					head = curr;</span><br><span class="line">					p = head;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					p.next = curr;</span><br><span class="line">					p = p.next;</span><br><span class="line">				&#125;</span><br><span class="line">				l2 = l2.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">			p.next = l2;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			p.next = l1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Description">Description</h1><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Valid Parentheses]]></title>
    <link href="http://yoursite.com/2015/12/18/Valid-Parentheses/"/>
    <id>http://yoursite.com/2015/12/18/Valid-Parentheses/</id>
    <published>2015-12-18T01:29:58.000Z</published>
    <updated>2015-12-18T01:35:19.279Z</updated>
    <content type="html"><![CDATA[<h1 id="Desription">Desription</h1><blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
<p>Subscribe to see which companies asked this question</p>
</blockquote>
<a id="more"></a>
<h1 id="解题思路">解题思路</h1><p>用栈来做这道题就很容易了，将字符入栈时和栈顶元素比较，如果配对就弹出栈顶元素，否则入栈。当最后栈为空时说明完全匹配，是合法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">         <span class="keyword">int</span> len = s.length();</span><br><span class="line">	         <span class="keyword">char</span> in;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        	 in = s.charAt(i);</span><br><span class="line">        	 <span class="keyword">switch</span> (in) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">				<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; <span class="string">')'</span> == stack.peek())&#123;</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					stack.push(in);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">				<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; <span class="string">'('</span> == stack.peek())&#123;</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					stack.push(in);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">				<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; <span class="string">']'</span> == stack.peek())&#123;</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					stack.push(in);</span><br><span class="line">				&#125;	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">				<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; <span class="string">'['</span> == stack.peek())&#123;</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					stack.push(in);</span><br><span class="line">				&#125;		</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">				<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; <span class="string">'&#125;'</span> == stack.peek())&#123;</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					stack.push(in);</span><br><span class="line">				&#125;		</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">				<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; <span class="string">'&#123;'</span> == stack.peek())&#123;</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					stack.push(in);</span><br><span class="line">				&#125;				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">        	 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Desription">Desription</h1><blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
<p>Subscribe to see which companies asked this question</p>
</blockquote>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Implement Stack using Queues]]></title>
    <link href="http://yoursite.com/2015/12/18/Implement-Stack-using-Queues/"/>
    <id>http://yoursite.com/2015/12/18/Implement-Stack-using-Queues/</id>
    <published>2015-12-18T01:20:16.000Z</published>
    <updated>2015-12-18T01:28:43.579Z</updated>
    <content type="html"><![CDATA[<h1 id="Description">Description</h1><p>Implement the following operations of a stack using queues.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>empty() – Return whether the stack is empty.</p>
<p>此题的要求就是用队列来实现栈</p>
<h1 id="解题思路">解题思路</h1><p>用一个队列的话很难实现，用两个队列就很容易实现了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建两个队列</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	Queue&lt;Integer&gt; p = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// Push element x onto stack.</span></span><br><span class="line">    <span class="comment">//往队列中添加元素，如果都为空，则随便选取一个添加，如果一个为空另一个不为空，则往不为空的队列中添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.isEmpty() &amp;&amp; p.isEmpty() || !q.isEmpty() &amp;&amp; p.isEmpty())&#123;</span><br><span class="line">        	q.add(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	p.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line">    <span class="comment">//将不为空的队列中的元素移出到另一个为空的队列除最后一个元素，然后将最后一个元素删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> len = q.isEmpty() ? p.size() : q.size();</span><br><span class="line">        <span class="keyword">if</span>(!q.isEmpty())&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        		p.add(q.remove());</span><br><span class="line">        	&#125;</span><br><span class="line">        	q.remove();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        		q.add(p.remove());</span><br><span class="line">        	&#125;</span><br><span class="line">        	p.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the top element.</span></span><br><span class="line">    <span class="comment">//将不为空的队列中的元素移出到另一个为空的队列除最后一个元素，然后获取最后一个元素的值并移到另一个队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> len = q.isEmpty() ? p.size() : q.size();</span><br><span class="line">    	<span class="keyword">int</span> res ;</span><br><span class="line">        <span class="keyword">if</span>(!q.isEmpty())&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        		p.add(q.remove());</span><br><span class="line">        	&#125;</span><br><span class="line">        	res = q.peek();</span><br><span class="line">        	p.add(q.remove());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        		q.add(p.remove());</span><br><span class="line">        	&#125;</span><br><span class="line">        	res = p.peek();</span><br><span class="line">        	q.add(p.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return whether the stack is empty.</span></span><br><span class="line">    <span class="comment">//两个队列都为空时说明栈为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty() &amp;&amp; p.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Description">Description</h1><p>Implement the following operations of a stack using queues.</p>
<p>push(x) – Push element x onto sta]]>
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Contains Duplicate II]]></title>
    <link href="http://yoursite.com/2015/12/18/Contains-Duplicate-II/"/>
    <id>http://yoursite.com/2015/12/18/Contains-Duplicate-II/</id>
    <published>2015-12-18T01:03:37.000Z</published>
    <updated>2015-12-18T01:19:14.156Z</updated>
    <content type="html"><![CDATA[<h1 id="Description">Description</h1><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.<br><a id="more"></a><br>题目大意是判断给定一个数组和整数K，是否存在两个不相等的下标i和j，使得nums[i]=nums[j],并且i-j&lt;=k</p>
<h1 id="解题思路">解题思路</h1><p>一种解法是利用HashSet,从头开始遍历数组，检测数组元素是否在HashSet中，如果不在，将元素添加到HashSet中，记录添加到中的元素的下标，否则返回false，当添加元素的下标和起始下标之差大于K是，将起始坐标对应的元素从集合中删除，然后起始坐标加1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!set.contains(nums[i])) &#123;</span><br><span class="line">			set.add(nums[i]);</span><br><span class="line">			end++;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(end -start &gt; k)&#123;</span><br><span class="line">			set.remove(nums[start]);</span><br><span class="line">			start++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Description">Description</h1><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.<br>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Contains Duplicate]]></title>
    <link href="http://yoursite.com/2015/12/18/Contains-Duplicate/"/>
    <id>http://yoursite.com/2015/12/18/Contains-Duplicate/</id>
    <published>2015-12-18T00:57:10.000Z</published>
    <updated>2015-12-18T01:03:10.414Z</updated>
    <content type="html"><![CDATA[<h1 id="Description">Description</h1><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.<br><a id="more"></a><br>题目大意就是判断一个整数数组中是否有重复的元素。</p>
<h1 id="解题思路">解题思路</h1><p>这道题比较容易想到的是使用HashSet来判断是否有重复元素（将所有元素放入到HashSet,如果HashSet的大小和数组的大小一样，说明没有重复元素）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; nums.length;i++)</span><br><span class="line">	 set.add(nums[i]);</span><br><span class="line"><span class="keyword">if</span>(set.size() == nums.length)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Description">Description</h1><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.<br>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Remove Nth Node From End of List]]></title>
    <link href="http://yoursite.com/2015/12/17/Remove-Nth-Node-From-End-of-List/"/>
    <id>http://yoursite.com/2015/12/17/Remove-Nth-Node-From-End-of-List/</id>
    <published>2015-12-17T07:40:59.000Z</published>
    <updated>2015-12-17T09:58:34.120Z</updated>
    <content type="html"><![CDATA[<h2 id="Description:">Description:</h2><p>Given a linked list, remove the nth node from the end of list and return its head.<br>For example<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, and n = <span class="number">2</span>.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>.</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>题目大意就是删除给定链表中的倒数第N个节点</p>
<h1 id="解题思路">解题思路</h1><p>由于是单向链表，所以难点在于确定倒数第N个节点的准确位置，这里我们可以用两个指针来解决此问题（两个指针的间隔距离为N，然后将两个指针同时移动，直到一个指针到达链表末尾，此时另一个指针的位置就是倒数第N个节点的位置）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//设置两个指针，用以确定待删除节点的位置</span></span><br><span class="line">	ListNode p = head;</span><br><span class="line">	ListNode q = head;</span><br><span class="line">       <span class="comment">//移动其中的一个节点，使两个节点的间距为N</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		p = p.next;</span><br><span class="line">       <span class="comment">//如果移动距离为N后，此节点为null，说明要删除的节点为首节点</span></span><br><span class="line">	<span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">		head = head.next;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//处理待删除节点不是首节点的情况</span></span><br><span class="line">	<span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			q = q.next;</span><br><span class="line">		p = p.next;</span><br><span class="line">	&#125;</span><br><span class="line">			q.next = q.next.next;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Description:">Description:</h2><p>Given a linked list, remove the nth node from the end of list and return its head.<br>For example<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, and n = <span class="number">2</span>.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>.</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Longest Common Prefix]]></title>
    <link href="http://yoursite.com/2015/12/17/Longest-Common-Prefix/"/>
    <id>http://yoursite.com/2015/12/17/Longest-Common-Prefix/</id>
    <published>2015-12-17T07:27:05.000Z</published>
    <updated>2015-12-17T07:39:37.868Z</updated>
    <content type="html"><![CDATA[<p>Description:Write a function to find the longest common prefix string amongst an array of strings.<br><a id="more"></a><br>此题的要求是要找出字符串的最长公共子前缀。</p>
<h1 id="解题思路">解题思路</h1><p>这道题的一种解法是：随便选取一个字符串，如果存在最长公共子前缀，一定在此字符串里，然后将此字符串和其余字符串作比较来获得最长公共子前缀。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">      		<span class="keyword">if</span> (strs.length == <span class="number">0</span>)</span><br><span class="line">		  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">             <span class="comment">//选取一个字符串用以和其它字符串作比较</span></span><br><span class="line">			String prefix = strs[<span class="number">0</span>];</span><br><span class="line">		String res = <span class="string">""</span>;</span><br><span class="line">           <span class="comment">//遍历剩余的字符串，对每一个字符串与选定的作比较</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(prefix.length() == <span class="number">0</span> || strs[i].length() == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            <span class="comment">//获得两个带比较字符串的最短长度</span></span><br><span class="line">		<span class="keyword">int</span> len = prefix.length() &gt; strs[i].length() ? strs[i].length() : prefix.length();</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="comment">//记录像个字符串具有最长公共子前缀的下标</span></span><br><span class="line">			<span class="keyword">if</span> (prefix.charAt(j) != strs[i].charAt(j)) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">//获得最长公共子前缀</span></span><br><span class="line">		prefix = prefix.substring(<span class="number">0</span>,j);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prefix;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Description:Write a function to find the longest common prefix string amongst an array of strings.<br>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrome Number]]></title>
    <link href="http://yoursite.com/2015/12/17/Palindrome-Number/"/>
    <id>http://yoursite.com/2015/12/17/Palindrome-Number/</id>
    <published>2015-12-17T06:00:51.000Z</published>
    <updated>2015-12-17T10:09:22.516Z</updated>
    <content type="html"><![CDATA[<p>Description：Determine whether an integer is a palindrome. Do this without extra space<br><a id="more"></a><br>Palindrome Number 就是一个整数正序和逆序所表示的数是一样的。<br>题目的大概意思就是用一个算法来识别给定的任意整数是不是Palindrome Number</p>
<h1 id="解题思路：">解题思路：</h1><ol>
<li><p>看到这题的时候，首先想到的是将数字转换成字符串，然后将字符串reverse，然后再比较两个字符串是否相等。但是题目中说明了不能使用额外空间，所以这种思路不可行（但是LeetCode貌似并没有对空间地址进行检查，用这种思路实现提交通过了，下面是具体的实现代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	String old = x+<span class="string">""</span>;</span><br><span class="line">        	String res = <span class="string">""</span>;</span><br><span class="line">               <span class="comment">//将数字逆序存储为字符串</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i = old.length() - <span class="number">1</span> ;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        		res += old.charAt(i);</span><br><span class="line">        	&#125;</span><br><span class="line">               <span class="comment">//比较正序和逆序字符串是否相等</span></span><br><span class="line">        	<span class="keyword">if</span>(old.equals(res))</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个整数是Palindrome Number，那么就意味着它是对称的，所以我们可以来比较第一位和最后一位数字，然后比较第二位和倒数第二位，依次类推。以下是具体的代码实现（这种方法的实现要比第一种快一倍多）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">10</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> digit = x;</span><br><span class="line">       <span class="comment">//计算出整数有多少位</span></span><br><span class="line">		<span class="keyword">while</span>(digit &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		d++;</span><br><span class="line">		digit = digit / <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">int</span> left = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span> );</span><br><span class="line">		<span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="comment">//比较左边和右边的数字</span></span><br><span class="line"> 			<span class="keyword">if</span>( x / left % <span class="number">10</span> != x / right % <span class="number">10</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> 			left /= <span class="number">10</span>;</span><br><span class="line"> 			right *= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Description：Determine whether an integer is a palindrome. Do this without extra space<br>]]>
    
    </summary>
    
      <category term="LeetCode Easy" scheme="http://yoursite.com/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SetAbout]]></title>
    <link href="http://yoursite.com/2015/12/14/SetAbout/"/>
    <id>http://yoursite.com/2015/12/14/SetAbout/</id>
    <published>2015-12-14T06:50:25.000Z</published>
    <updated>2015-12-17T07:16:50.414Z</updated>
    <content type="html"><![CDATA[<p>主要结合源码来分析与set集合的相关实现<br><a id="more"></a><br>Set集合中不能存储重复的元素，相同的元素只存储一次。</p>
<h1 id="HashSet">HashSet</h1><p>HashSet 内部的实现是基于HashMap(<strong>LinkedHashSet的实现基于LinkedHashMap，其它地方均与HashSet相同，LinkedHashSet继承自HashSet</strong>)的，也就是说HashSet中的数据是存放在HashMap中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个瞬时的HashMap</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure></p>
<h3 id="add_方法">add 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//往map中存放数据，key值为要添加的元素，PRESENT为一个Object对象</span></span><br><span class="line"><span class="comment">//官方定义： private static final Object PRESENT = new Object();</span></span><br><span class="line"><span class="comment">//由于添加进的元素是无序的，所以添加元素只有一种方法，即根据元素来添加，不能指定位置。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove_方法">remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>主要结合源码来分析与set集合的相关实现<br>]]>
    
    </summary>
    
      <category term="Java相关" scheme="http://yoursite.com/tags/Java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ListAbout]]></title>
    <link href="http://yoursite.com/2015/12/14/ListAbout/"/>
    <id>http://yoursite.com/2015/12/14/ListAbout/</id>
    <published>2015-12-14T05:52:22.000Z</published>
    <updated>2015-12-17T07:15:43.924Z</updated>
    <content type="html"><![CDATA[<p>主要结合源码来介绍一些常用集合的的实现<br><a id="more"></a></p>
<h1 id="ArrayList(基于单线程的)">ArrayList(基于单线程的)</h1><p>ArrayList的实现方式是基于数组的，因此它的<strong>插入，删除</strong>操作比较耗时，但它在<strong>随机访问</strong>方面的速度不及快。源码中定义了一个Object数组用来存储添加进来的元素,Object数据是用transient来修饰的，表明它不能被用来持久化，只存在于内存中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></p>
<p>ArrayList 中比较常用的方法有add,remove等等，在这里主要分析这两个方法。</p>
<h3 id="add_方法">add 方法</h3><p>add方法实现的关键地方在于找到要添加元素的位置，然后将此位置之后的数组元素往后移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果没有指定元素添加的位置，默认将元素添加到数组的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">//如果指定添加的位置，则将指定位置之后的元素往后移（包含指定元素，否则如果指定位置有元素的话会被新元素替换掉）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="remove_方法">remove 方法</h1><p>remove的实现与add方法差不多，找到要删除的元素的位置，然后将此元素之后的所有元素往前移一位来达到删除元素的目的，然后将数组的最后一位置为null,以便于Jvm回收内存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="LinkedList">LinkedList</h1><p>LinkedList的实现方式是基于双链表的，它的<strong>插入，删除</strong>操作效率高。数据的存储是用节点来存储的,LinkedList 定义了两个瞬时节点指针，一个指向第一个节点,一个指向最后一个节点。<br>源码中节点的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Pointer to first node.</span><br><span class="line">    * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">    *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Pointer to last node.</span><br><span class="line">    * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">    *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.item = element;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就简单介绍下LinkedList中add和remove方法的实现</p>
<h3 id="add_方法-1">add 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//默认情况下往链表的默认添加新元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//创建一个新的节点来表示新元素</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">//判断链表是否存在，不存在，则新的节点为第一个节点，如果存在，将原来最后的节点的下一个元素指向新的节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//指定元素的位置   </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="comment">//判断添加元素的位置是否是末尾，如果是，则在末尾添加，否则添加到对应的位置</span></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在某个节点之前插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//返回指定位置的节点</span></span><br><span class="line"> <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">		<span class="comment">//如果index小于元素个数的一半，则从开始节点往后搜索，否则从最后一个节点往前搜过，这样做主要是为了提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove_方法-1">remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//删除指定节点</span></span><br><span class="line">  <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">        <span class="comment">//处理待删除节点是否为第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//处理待删除节点是否为最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除指定位置的节点</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>主要结合源码来介绍一些常用集合的的实现<br>]]>
    
    </summary>
    
      <category term="Java相关" scheme="http://yoursite.com/tags/Java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nested Classes]]></title>
    <link href="http://yoursite.com/2015/12/11/InnerClass/"/>
    <id>http://yoursite.com/2015/12/11/InnerClass/</id>
    <published>2015-12-11T08:01:33.000Z</published>
    <updated>2015-12-17T07:15:45.482Z</updated>
    <content type="html"><![CDATA[<p>Nested Classes 主要分为两类，一类是Static Nested Classes,一类是Inner Classes<br><a id="more"></a></p>
<p>#Static Nested Classes<br>Static Nested Classes 与它的<strong>外部类</strong>相关联，在Static Nested Classes中无法访问它的外部类的非静态成员变量以及方法，它只能访问到静态成员变量和方法。</p>
<p>####例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"vincent"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123; <span class="comment">//class可加访问修饰符，默认是包访问权限</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">"good"</span>; <span class="comment">//编译报错，无法访问非静态变量</span></span><br><span class="line">        age = <span class="number">2</span>; <span class="comment">//正常，无错误</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####如何调用Static Nested Classes?<br>以上面的例子为基础，调用方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.B b = <span class="keyword">new</span> A.B();</span><br></pre></td></tr></table></figure></p>
<p>#Inner Classes<br>Inner Classes 与它的<strong>外部类的对象</strong>相关联（注意与Static Nested Classes的区别），在Inner Classes 中能够访问它外部类的对象的所有方法以及成员变量，但是<strong>不能定义静态方法和变量</strong></p>
<p>####例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####调用Inner Classes:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br></pre></td></tr></table></figure></p>
<p>####注意：</p>
<ol>
<li>当Inner Classes中定义的成员变量与外部类中重名时，要想在Inner Classes中使用外部类中的成员边需要一<strong>Outer.this.param</strong>的形式(Outer指的是外部类，param指的要使用的成员变量名)</li>
<li>Inner Class 有两种特殊情况，<strong>Local Classes</strong> 和 <strong>Anonymous Classes</strong><br>#####Local Classes<br>Local Classes 是被定义在代码块中，而不是在类中。下面就是Local Classes的一个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123; </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>#####Anonymous Classes<br>Anonymous Classes允许在同一时刻来声明和实例化一个类，例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">H</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">   H h = <span class="keyword">new</span> H()&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Hi"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Nested Classes 主要分为两类，一类是Static Nested Classes,一类是Inner Classes<br>]]>
    
    </summary>
    
      <category term="Java相关" scheme="http://yoursite.com/tags/Java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[k- 近邻算法]]></title>
    <link href="http://yoursite.com/2015/10/26/machine-learning/"/>
    <id>http://yoursite.com/2015/10/26/machine-learning/</id>
    <published>2015-10-26T01:32:20.000Z</published>
    <updated>2015-12-11T02:14:49.882Z</updated>
    <content type="html"><![CDATA[<p>基本概念：采用不同特征值之间的距离来进行分类<br><strong>优点：</strong> 精度高，对异常值不敏感，无数据输入假定<br><strong>缺点：</strong> 计算复杂度高，空间复杂度高<br><a id="more"></a></p>
<h1 id="算法的一般流程">算法的一般流程</h1><ol>
<li>计算已知类别中数据中的点与当前点之间的距离<blockquote>
<p>例：</p>
<ol>
<li>如果数据存在两个特征值，假设当前点为($ x,y$),已知数据集中的一个数据为($ a,b$)<br>距离：$ \sqrt{(x-a)^2+(y-b)^2}$</li>
<li>如果存在$n$个特征值,假设当前点为$ (a_1,a_2,\ldots,a_n)$,已知数据集中的一个数据为$ (b_1,b_2,\ldots,b_n)$<br>距离:$ \sqrt{(a_1-b_1)^2+(a_2-b_2)^2+\ldots+(a_n-b_n)^2}$</li>
</ol>
</blockquote>
</li>
<li>将距离按照递增排序</li>
<li>选取与当前点距离最小的K个点</li>
<li>计算出前K个点所在类别的出现频率</li>
<li><p>返回前K个点中频率出现最高的类别作为当前点的预测分类</p>
<h1 id="算法代码(python)">算法代码(python)</h1><p><strong>下面的代码只给出类有两个特征值的K-近邻算法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inX,dataSet,labels,k)</span> :</span></span><br><span class="line">     <span class="string">"""</span><br><span class="line">   :param inX: 需要计算的点</span><br><span class="line">   :param dataSet: 已知的数据集合，例如：</span><br><span class="line">   [[1.0, 1.1],</span><br><span class="line">   [1.0, 2.1],</span><br><span class="line">   [0, 0],</span><br><span class="line">   [0, 0.1]]</span><br><span class="line">   :param labels: 已知的类别，与dataSet对应，例如：</span><br><span class="line">   ['A', 'A','B','B']，从左往右，其中第一个A所对应的数据为[1.0,1.1],第二个A所对应的数据为[1.0,2.1],以此类推</span><br><span class="line">   :param k:</span><br><span class="line">   :return: 对于输入数据所预测的类别</span><br><span class="line">   """</span></span><br><span class="line">   dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">   diffMat = tile(inX,(dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">   sqDiffMat = diffMat ** <span class="number">2</span></span><br><span class="line">   sqDistances = sqDiffMat.sum(<span class="number">1</span>)</span><br><span class="line">   distances = sqDistances ** <span class="number">0.5</span></span><br><span class="line">   sortedDistances = distances.argsort()</span><br><span class="line">   classCount = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(k) :</span><br><span class="line">       voteIlabel = labels[sortedDistances[i]]</span><br><span class="line">       classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">   sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="keyword">True</span>)</span><br><span class="line">   <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>基本概念：采用不同特征值之间的距离来进行分类<br><strong>优点：</strong> 精度高，对异常值不敏感，无数据输入假定<br><strong>缺点：</strong> 计算复杂度高，空间复杂度高<br>]]>
    
    </summary>
    
      <category term="machineLearning" scheme="http://yoursite.com/tags/machineLearning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flume的安装部署]]></title>
    <link href="http://yoursite.com/2015/10/24/flume-about/"/>
    <id>http://yoursite.com/2015/10/24/flume-about/</id>
    <published>2015-10-24T12:03:44.000Z</published>
    <updated>2015-10-28T10:58:48.105Z</updated>
    <content type="html"><![CDATA[<h2 id="准备">准备</h2><ol>
<li>flume1.6的安装包 <a href="http://www.apache.org/dyn/closer.lua/flume/1.6.0/apache-flume-1.6.0-bin.tar.gz" target="_blank" rel="external">下载</a></li>
<li>解压<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf apache-flume-<span class="number">1.6</span>.<span class="number">0</span>-bin.tar.gz -C ~/Devtool/flume</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置">配置</h2><ol>
<li>进入解压后flume的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Devtool/flume</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>在conf目录下建立以<strong>.conf</strong>结尾的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch conf/examples.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑<em>examples.conf</em>文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi conf/examples.conf</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>添加如下内容：</p>
<blockquote>
<p>#配置source的名字<br>HdfsAgent.sources = s1<br>#配置sink的名字<br>HdfsAgent.sinks = k1<br>#配置channel的名字<br>HdfsAgent.channels = c1<br>#配置与source相关的属性<br>#配置source类型为监听目录<br>HdfsAgent.sources.s1.type = spooldir<br>#配置监听的目录<br>HdfsAgent.sources.s1.spoolDir = /home/test<br>HdfsAgent.sources.s1.fileHeader = true<br>HdfsAgent.sources.s1.deletePolicy = immediate<br>HdfsAgent.sources.s1.fileHeader = true<br>#配置sink的相关属性(将数据写入到hdfs)<br>HdfsAgent.sinks.k1.type = hdfs<br>#hdfs的地址<br>HdfsAgent.sinks.k1.hdfs.path = hdfs://124.16.136.144:8020/user/hive/warehouse/user4/%Y%m%d/%H<br>#写入到hdfs上的文件的前缀<br>HdfsAgent.sinks.k1.hdfs.filePrefix = %{file}<br>HdfsAgent.sinks.k1.hdfs.fileType = DataStream<br>HdfsAgent.sinks.k1.hdfs.rollInterval = 10<br>HdfsAgent.sinks.k1.hdfs.rollCount = 0<br>HdfsAgent.sinks.k1.hdfs.rollSize = 0<br>#HdfsAgent.sinks.k1.hdfs.maxOpenFiles = 1<br>HdfsAgent.sinks.k1.hdfs.writeFormat = Text<br>HdfsAgent.sinks.k1.hdfs.batchSize = 10<br>HdfsAgent.sinks.k1.hdfs.inUsePrefix = .<br>#配置channel的相关属性<br>HdfsAgent.channels.c1.type = memory<br>HdfsAgent.channels.c1.capacity = 500000<br>HdfsAgent.channels.c1.transactionCapacity = 100000<br>HdfsAgent.channels.c1.byteCapacity = 1000000000<br>#配置source的channel<br>HdfsAgent.sources.s1.channels = c1<br>#配置sink的channel<br>HdfsAgent.sinks.k1.channel = c1</p>
</blockquote>
<p><a href="http://flume.apache.org/FlumeUserGuide.html" target="_blank" rel="external">更多配置信息</a></p>
<h2 id="启动">启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/flume-ng agent -n HdfsAgent -c conf <span class="operator">-f</span> conf/examples.conf -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="准备">准备</h2><ol>
<li>flume1.6的安装包 <a href="http://www.apache.org/dyn/closer.lua/flume/1.6.0/apache-flume-1.6.0-bin.tar.gz">下载</a></li>
<li>解压<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf apache-flume-<span class="number">1.6</span>.<span class="number">0</span>-bin.tar.gz -C ~/Devtool/flume</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置">配置</h2><ol>
<li>进入解压后flume的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Devtool/flume</span><br></pre></td></tr></table></figure>
</li>
</ol>]]>
    
    </summary>
    
      <category term="flume" scheme="http://yoursite.com/tags/flume/"/>
    
  </entry>
  
</feed>
